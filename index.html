<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiSEBand</title>
    <script>
        let bc, winId

        function getCurDateTimeStr() {
            const now = new Date()
            let ret = now.getFullYear().toString() + "-" + (now.getMonth() + 1).toString().padStart(2, "0") + "-" + now.getDate().toString().padStart(2, "0") + " " + 
                      now.getHours().toString().padStart(2, "0") + ":" + now.getMinutes().toString().padStart(2, "0") + ":" + now.getSeconds().toString().padStart(2, "0")
            return ret
        }

        // function getDateTimeStamp(str) { //str = 2012-08-02 14:12:04
        //     const d = str.match(/\d+/g) //extract date parts
        //     return new Date(d[0], d[1] - 1, d[2], d[3], d[4], d[5])
        // }

        function procLocalStorage() { //Main.vue에도 거의 동일한 로직이 있는데 둘 다 공통으로 모듈화하기가 쉽지 않아 일단 중복 코딩 (5초는 Main.vue에도 있음을 유의)
            if (!localStorage.winId) {
               localStorage.winId = winId
               localStorage.winDt = getCurDateTimeStr()
            // } else { //이미 다른 탭이 위너로 자리잡고 있다고 봐야 하나 (자기자신이나 다른 탭이) 비정상적인 브라우저 종료로 미처 delete 안되었을 경우도 고려
            //     const winDt = localStorage.winDt //localStorage.winId가 있으면 localStorage.winDt도 무조건 있다고 보기
            //     const dtPrev = getDateTimeStamp(winDt)
            //     const sec = parseInt(((new Date()) - dtPrev) / 1000) //return seconds
            //     if (sec > 5) { //5초 지나면 새로 위너에 도전하기
            //         localStorage.winId = winId
            //         localStorage.winDt = getCurDateTimeStr()
            //     }
            }
        }

        const start = new Promise(async (resolve, reject) => {
            if (!window.Notification) reject('이 브라우저가 window.Notification을 지원하지 않습니다.') //window.Notification || window.mozNotification || window.webkitNotification
            const permission = await window.Notification.requestPermission()
            if (permission != "granted") reject('알림이 허용되어 있지 않아서 메시지 도착을 알 수 없는 경우가 발생합니다. 알림을 허용하시기 바립니다.')
            resolve() //html5 notification은 https만 지원 (localhost에서는 http도 지원 - 크롬 테스트 OK)
        })

        function getBroadcast(data) {
            console.log(JSON.stringify(data))
            if (data.code == "dead") {
                procLocalStorage()
            }
        }

        start.then(() => {
            bc = new BroadcastChannel("wbRealtime") //각탭의 index.html <=> index.html
            bc.onmessage = (e) => { getBroadcast(e.data) }
            winId = Math.floor(Math.random() * (999999 - 100000)) + 100000
            const tag = document.querySelector("#winid")
            tag.innerText = winId //Main.vue에 전달
            procLocalStorage()
            //sessionStorage.pageShown = 'Y'
        }).catch(error => {
            alert(error)
        }) //.finally(() => {})

        window.addEventListener("beforeunload", (e) => { //Main.vue에서는 구현 어려워 여기서 locaStorage로 각 탭의 Main.vue와 통신함
            if (!bc) return
            if (localStorage.winId == winId) { //console.log("beforeunload") //OK
                delete localStorage.winId //내가 위너면 내가 죽을 때 위너 자리 내놓음
                delete localStorage.winDt
                bc.postMessage({ code: "dead" }) //winner is dead
            } //내가 위너가 아니면 죽을 때 알릴 필요없음
            bc.close()
        })
    </script>
  </head>
  <body oncontextmenu="return false"><!-- 컨텍스트메뉴 만들어 사용하는데 .vue에서 .prevent가 안먹혀 여기서 일단 처리함 -->
    <div id="app"></div>
    <div id="winid" style="display:none"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
